{
  "language": "Solidity",
  "sources": {
    "contracts/FundMe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\nimport \"./PriceConverter.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n//using custom errors\n//makes the contract more gas efficient because we don't have to store error strings in memory\n\nerror NotOwner();\n\n\ncontract FundMe{\n\n    using PriceConverter for uint256;\n    //meaning any uint256 variable can now call functions from this library\n    //as if it were an object\n\n    //$50 at least\n    //uint256 public minimumUSD = 50 * 1e18; beacuse the value returned by other functions will have 18 zeros\n    address[] public funders;\n    mapping(address => uint256) public addressToAmoutDonated;\n\n    //making the variables immutable and constant saves gas because they require less memory\n    //and there values can be read at compile time and stored directly in the byte code\n    //constant because we're also initializing it here\n    //immutable because we're at least setting its value once (inside the constructor)\n\n    address public immutable i_owner;\n    uint256 public constant MINIMUM_USD = 50 * 1e18;\n\n    AggregatorV3Interface public priceFeedObject;\n\n    //constructors run when the contract is deployed, so when this runs the msg.sender will be the contrac owner\n    constructor(address priceFeedAddress){\n        i_owner = msg.sender;\n        priceFeedObject = AggregatorV3Interface(priceFeedAddress);\n    }\n\n    function fund() public payable{\n        //getConversionRate(msg.value) becomes msg.value.getConversionRate();\n        //and the msg.value becomes the first argument passed to the getConversionRate()\n        require(msg.value.getConversionRate(priceFeedObject) > MINIMUM_USD, \"Must send greater than 50 dollars!\");\n        funders.push(msg.sender);\n        addressToAmoutDonated[msg.sender] = msg.value;\n    }\n\n    //the onlyOwner modifier will run the modifier block and check if the sender is owner (user defined modifier)\n    function widthdraw() public onlyOwner{\n\n        for(uint256 i = 0; i < funders.length; i++){\n            //getting the address one by one\n            address funder = funders[i];\n\n            //setting the amount on this address key to 0\n            addressToAmoutDonated[funder] = 0;\n        }\n\n        //now we need to reset the funders array as well\n\n        //we are just gonna make it point to a new address array with 0 elements in it to begin with\n        funders = new address[](0);\n        (bool callSuccess, ) = payable(msg.sender).call{value: address(this).balance}(\"\");\n        require(callSuccess, \"Call failed!\");\n\n        //three ways to send native blockchain currency\n\n        //transfer function\n        // msg.sender.transfer(this.balance)\n        //typecasting *msg.sender* address to a *payable* address (where we can send money to)\n        //typecasting *this* (current address reference) to, well, an address\n        //automatically reverts\n        // payable(msg.sender).transfer(address(this).balance)\n\n        //send function\n        //returns a bool, so we need to explicitly check for success and revert\n        // bool isSent = payable(msg.sender).send(address(this).balance);\n        // require(isSent, \"Couldn't send money!\");\n\n        //call function --> recommended way -- a lower level call\n        //this allows us to call any function on the entirety of ethereum blockchain\n        //we're not really calling any function here so we're gonna leave that argument as an empty string\n        //although what we can do is send some money with it\n        //so we're sending the current balance and passing in the *value* that we usually pass when calling the fund function\n\n        //the bytes variable stores whatever is returned by the function call we specify\n        //using the memory keyword because bytes is gonna be an array (which is not a primitive data type)\n\n        //(bool callSuccess, bytes memory dataReturned) = payable(msg.sender).call{value: address(this).balance}(\"\");\n    }\n\n    modifier onlyOwner{\n        //require(msg.sender == i_owner, \"Unauthorized access! Sender is not owner\"); //--> do this first\n        \n        //same as the above require, new and recommended (more gas efficient)\n        if(msg.sender != i_owner){\n            revert NotOwner();\n        }\n        _; //--> execute the rest of the function later\n    }\n\n    //           is msg.data empty?\n    //                /      \\\n    //              yes       no\n    //              /          \\\n    //         recieve hai?    fallback()\n    //          /      \\\n    //         yes     no\n    //        /          \\\n    //    receive()    fallback()\n\n    //what happens when someone sends this contract money without calling the fund function???\n    //just like how I was trying to send ETH through MetaMask, I can't really call the fund function there, right?\n\n    //so when that's the case, the *receive* function will run\n    //receive function runs when there is no data with the transaction\n    // ie, when it's not specified which function to call\n    receive() external payable{\n        fund();\n    }\n\n    //fallback is another function that runs when the function is specified but it doesn't exit\n    //that's why it's a fallback ¯\\_(ツ)_/¯ \n    fallback() external{\n        fund();\n    }\n}"
    },
    "contracts/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n//the logic for this interface is defined in the smart contract whose address is pasted below\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n//the import statement referes to the npm package on npmjs website\r\n\r\nlibrary PriceConverter{\r\n\r\n    //gonna use chainlink data feeds to get the price\r\n    function getPrice(AggregatorV3Interface priceFeed) internal view returns(uint256){\r\n        //we are gonna contact a contract that can comminucate to the chainlink data feed to get the price\r\n        //for that, we need the address of the contract, and the ABI (interface which defines all the functions)\r\n\r\n        (\r\n            ,int256 price,,,\r\n        ) = priceFeed.latestRoundData();\r\n        //price of ETH in terms of USD\r\n        //the price is gonna be in dollars ie 150000000000 -> actual is 1500.00000000\r\n        //because this contract has 8 decimal places, can be checked by calling the demicals()\r\n\r\n        //typecasting to uint256 because msg.value is a uint256 variable\r\n\r\n        //the decimal places in the contract is 8, but our msg.value is gonna have 18 decimal places\r\n        //because 1 eth = 1000000000000000000 wei\r\n\r\n        //to match the decimal places we need to multiply the returned price with 8 decimal places with 1e10\r\n        // ie 1.0000000000\r\n\r\n        return uint256 (price * 1e10);\r\n    }\r\n\r\n\r\n    //the first argument is what the function is being called on\r\n    //kinda like the implicit argument, but here its kinda explicit\r\n\r\n    function getConversionRate(uint256 ethAmount, AggregatorV3Interface priceFeedObject) internal view returns (uint256){\r\n        uint256 ethPrice = getPrice(priceFeedObject);\r\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18;\r\n        return ethAmountInUsd;\r\n    }\r\n}"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}